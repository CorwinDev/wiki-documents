"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7171],{15680:(e,n,i)=>{i.d(n,{xA:()=>d,yg:()=>S});var t=i(96540);function o(e,n,i){return n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i,e}function r(e,n){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),i.push.apply(i,t)}return i}function a(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?r(Object(i),!0).forEach((function(n){o(e,n,i[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(i,n))}))}return e}function s(e,n){if(null==e)return{};var i,t,o=function(e,n){if(null==e)return{};var i,t,o={},r=Object.keys(e);for(t=0;t<r.length;t++)i=r[t],n.indexOf(i)>=0||(o[i]=e[i]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)i=r[t],n.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(o[i]=e[i])}return o}var l=t.createContext({}),p=function(e){var n=t.useContext(l),i=n;return e&&(i="function"==typeof e?e(n):a(a({},n),e)),i},d=function(e){var n=p(e.components);return t.createElement(l.Provider,{value:n},e.children)},c="mdxType",_={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var i=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(i),u=o,S=c["".concat(l,".").concat(u)]||c[u]||_[u]||r;return i?t.createElement(S,a(a({ref:n},d),{},{components:i})):t.createElement(S,a({ref:n},d))}));function S(e,n){var i=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=i.length,a=new Array(r);a[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:o,a[1]=s;for(var p=2;p<r;p++)a[p]=i[p];return t.createElement.apply(null,a)}return t.createElement.apply(null,i)}u.displayName="MDXCreateElement"},42233:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>_,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var t=i(9668),o=(i(96540),i(15680));const r={description:"XIAO ESP32 Sense Use different Sleep Modes Consumptions",title:"XIAO ESP32S3 Sense Sleep Modes",keywords:["Sleep_Modes"],image:"https://files.seeedstudio.com//wiki/ESP32S3_Sense_SleepMode/1.png",slug:"/XIAO_ESP32S3_Consumption",last_update:{date:"08/27/2024",author:"Jason"}},a=void 0,s={unversionedId:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32S3/XIAO_ESP32S3_Sense_Consumption",id:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32S3/XIAO_ESP32S3_Sense_Consumption",title:"XIAO ESP32S3 Sense Sleep Modes",description:"XIAO ESP32 Sense Use different Sleep Modes Consumptions",source:"@site/docs/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32S3/XIAO_ESP32S3_Sense_Consumption.md",sourceDirName:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32S3",slug:"/XIAO_ESP32S3_Consumption",permalink:"/XIAO_ESP32S3_Consumption",draft:!1,editUrl:"https://github.com/Seeed-Studio/wiki-documents/blob/docusaurus-version/docs/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32S3/XIAO_ESP32S3_Sense_Consumption.md",tags:[],version:"current",lastUpdatedBy:"Jason",lastUpdatedAt:1724716800,formattedLastUpdatedAt:"Aug 27, 2024",frontMatter:{description:"XIAO ESP32 Sense Use different Sleep Modes Consumptions",title:"XIAO ESP32S3 Sense Sleep Modes",keywords:["Sleep_Modes"],image:"https://files.seeedstudio.com//wiki/ESP32S3_Sense_SleepMode/1.png",slug:"/XIAO_ESP32S3_Consumption",last_update:{date:"08/27/2024",author:"Jason"}},sidebar:"ProductSidebar",previous:{title:"Pin Multiplexing with Seeed Studio XIAO ESP32S3 (Sense)",permalink:"/xiao_esp32s3_pin_multiplexing"},next:{title:"WiFi for both versions",permalink:"/xiao_esp32s3_wifi_usage"}},l={},p=[{value:"Softare Preparetion",id:"softare-preparetion",level:2},{value:"Light Sleep-Mode",id:"light-sleep-mode",level:2},{value:"Introduce Light Sleep",id:"introduce-light-sleep",level:3},{value:"Wake-up Methods",id:"wake-up-methods",level:3},{value:"Use Light Sleep Code",id:"use-light-sleep-code",level:3},{value:"Deep Sleep-Mode",id:"deep-sleep-mode",level:2},{value:"Introduce Deep Sleep",id:"introduce-deep-sleep",level:3},{value:"Wake-up Methods",id:"wake-up-methods-1",level:3},{value:"Use Deep Sleep Code",id:"use-deep-sleep-code",level:3},{value:"Modem-Sleep",id:"modem-sleep",level:2},{value:"Introduce Modem-Sleep",id:"introduce-modem-sleep",level:3},{value:"Wake-up Methods",id:"wake-up-methods-2",level:3},{value:"Use Modem Sleep Code",id:"use-modem-sleep-code",level:3},{value:"To conclude",id:"to-conclude",level:2},{value:"Why use Deep Sleep mode",id:"why-use-deep-sleep-mode",level:3},{value:"Why use Light Sleep mode",id:"why-use-light-sleep-mode",level:3},{value:"Why use Modem Sleep mode",id:"why-use-modem-sleep-mode",level:3},{value:"In summary",id:"in-summary",level:3},{value:"Tech Support &amp; Product Discussion",id:"tech-support--product-discussion",level:2}],d={toc:p},c="wrapper";function _(e){let{components:n,...i}=e;return(0,o.yg)(c,(0,t.A)({},d,i,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("div",{style:{textAlign:"center"}},(0,o.yg)("img",{src:"https://files.seeedstudio.com/wiki/ESP32S3_Sense_SleepMode/1.png",style:{width:700,height:"auto"}})),(0,o.yg)("p",null,"ESP32 supports two major power saving modes: Light-sleep and Deep-sleep. According to the features used by an application, there are some sub sleep modes. See Sleep Modes for these sleep modes and sub sleep modes. Additionally, there are some power-down options that can be configured to further reduce the power consumption. See Power-down Options for more details."),(0,o.yg)("p",null,"Here, I will use some simple examples to demonstrate the use of these low-power sleep modes. All ESP32s are universal, and the development board I am using here is XIAO ESP32S3 Sense"),(0,o.yg)("div",{class:"table-center"},(0,o.yg)("table",{align:"center"},(0,o.yg)("tr",null,(0,o.yg)("th",null,"Seeed Studio XIAO ESP32S3 Sense")),(0,o.yg)("tr",null,(0,o.yg)("td",null,(0,o.yg)("div",{style:{textAlign:"center"}},(0,o.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/xiaoesp32s3sense.jpg",style:{width:250,height:"auto"}})))),(0,o.yg)("tr",null,(0,o.yg)("td",null,(0,o.yg)("div",{class:"get_one_now_container",style:{textAlign:"center"}},(0,o.yg)("a",{class:"get_one_now_item",href:"https://www.seeedstudio.com/XIAO-ESP32S3-Sense-p-5639.html"},(0,o.yg)("strong",null,(0,o.yg)("span",null,(0,o.yg)("font",{color:"FFFFFF",size:"4"}," Get One Now \ud83d\uddb1\ufe0f"))))))))),(0,o.yg)("h2",{id:"softare-preparetion"},"Softare Preparetion"),(0,o.yg)("p",null,"Before starting this article, you need to prepare some software installation work if you have not yet used all the hardware features on XIAO ESP32S3 Sense"),(0,o.yg)("p",null,"Below, I have provided the redirect link"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"https://wiki.seeedstudio.com/xiao_esp32s3_sense_mic/"},"Micrphone Use")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"https://wiki.seeedstudio.com/xiao_esp32s3_sense_filesystem/"},"MicroSD")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"https://wiki.seeedstudio.com/xiao_esp32s3_camera_usage/"},"Camera Use"))),(0,o.yg)("h2",{id:"light-sleep-mode"},"Light Sleep-Mode"),(0,o.yg)("h3",{id:"introduce-light-sleep"},"Introduce Light Sleep"),(0,o.yg)("p",null,"In Light-sleep mode, the digital peripherals, most of the RAM, and CPUs are clock-gated and their supply voltage is reduced. Upon exit from Light-sleep, the digital peripherals, RAM, and CPUs resume operation and their internal states are preserved."),(0,o.yg)("h3",{id:"wake-up-methods"},"Wake-up Methods"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Timer Wake-up"),(0,o.yg)("li",{parentName:"ul"},"External interrupt Wake-up"),(0,o.yg)("li",{parentName:"ul"},"Touch sensor Wake-up"),(0,o.yg)("li",{parentName:"ul"},"ULP coprocessor Wake-up"),(0,o.yg)("li",{parentName:"ul"},"GPIO Wake-up"),(0,o.yg)("li",{parentName:"ul"},"UART Wake-up"),(0,o.yg)("li",{parentName:"ul"},"UART target Wake-up"),(0,o.yg)("li",{parentName:"ul"},"Network socket Wake-up")),(0,o.yg)("p",null,"Detail Wake up Source information , you can watch it from ",(0,o.yg)("a",{parentName:"p",href:"https://docs.espressif.com/projects/esp-idf/en/v5.3/esp32/api-reference/system/sleep_modes.html"},(0,o.yg)("strong",{parentName:"a"},"Here"))),(0,o.yg)("h3",{id:"use-light-sleep-code"},"Use Light Sleep Code"),(0,o.yg)("p",null,"You can check the complete code on ESP IDF here, Because it's not very smooth to use on Arduino platform"),(0,o.yg)("h2",{id:"deep-sleep-mode"},"Deep Sleep-Mode"),(0,o.yg)("h3",{id:"introduce-deep-sleep"},"Introduce Deep Sleep"),(0,o.yg)("p",null,"In Deep-sleep mode, the CPUs, most of the RAM, and all digital peripherals that are clocked from APB_CLK are powered off. The only parts of the chip that remain powered on are:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},"RTC controller RTC")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},"ULP coprocessor ULP")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},"RTC FAST memory RTC")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},"RTC SLOW memory RTC"))),(0,o.yg)("h3",{id:"wake-up-methods-1"},"Wake-up Methods"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Timer Wake-up"),(0,o.yg)("li",{parentName:"ul"},"Touchpad Wake-up"),(0,o.yg)("li",{parentName:"ul"},"External Wake-up(ext0)"),(0,o.yg)("li",{parentName:"ul"},"External Wake-up(ext1)"),(0,o.yg)("li",{parentName:"ul"},"ULP Coprocessor Wake-up")),(0,o.yg)("p",null,"Detail Wake up Source information , you can watch it from ",(0,o.yg)("a",{parentName:"p",href:"https://docs.espressif.com/projects/esp-idf/en/v5.3/esp32/api-reference/system/sleep_modes.html"},(0,o.yg)("strong",{parentName:"a"},"Here"))),(0,o.yg)("h3",{id:"use-deep-sleep-code"},"Use Deep Sleep Code"),(0,o.yg)("p",null,"In in this code , i'am use Timer regard as Wakeup Source , Wake up every 7 seconds."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},'/*need inlcude head file*/\n#include "FS.h"\n#include "SD.h"\n#include "SPI.h"\n#include <ESP_I2S.h>\n#include "esp_camera.h"\n#include "camera_pins.h"\n\n\n/*set wake up tiem seven second*/\n#define uS_TO_S_FACTOR 1000000ULL /* Conversion factor for micro seconds to seconds */\n#define TIME_TO_SLEEP  7          /* Time ESP32 will go to sleep (in seconds) */\n#define CAMERA_MODEL_XIAO_ESP32S3 // Has PSRAM\n\nRTC_DATA_ATTR int bootCount = 0;\n\nI2SClass I2S;\n\n\n/*Declaration function*/\nvoid print_wakeup_reason();//print wake_up source \nvoid SDCard_enable();//SDCard begin \nvoid Microphone_enable();//Microphone begin \nvoid Camera_enable();//camera init \nvoid Deep_Sleep_enable();//start deep_sleep\nvoid close_SDCard();\nvoid close_Camera();\nvoid close_Microphone();\nvoid startCameraServer();\nvoid setupLedFlash(int pin);\n\n\n\nvoid setup() {\n  Serial.begin(115200);\n  while(!Serial);//Ensure that the serial port is enabled\n}\n\nvoid loop() {\n  while(!Serial);\n  /*enable or close your peripheral*/\n  Deep_Sleep_enable();\n  delay(10000);\n}\n\n\nvoid print_wakeup_reason() {\n  esp_sleep_wakeup_cause_t wakeup_reason;\n\n  wakeup_reason = esp_sleep_get_wakeup_cause();\n\n  switch (wakeup_reason) {\n    case ESP_SLEEP_WAKEUP_EXT0:     Serial.println("Wakeup caused by external signal using RTC_IO"); break;\n    case ESP_SLEEP_WAKEUP_EXT1:     Serial.println("Wakeup caused by external signal using RTC_CNTL"); break;\n    case ESP_SLEEP_WAKEUP_TIMER:    Serial.println("Wakeup caused by timer"); break;\n    case ESP_SLEEP_WAKEUP_TOUCHPAD: Serial.println("Wakeup caused by touchpad"); break;\n    case ESP_SLEEP_WAKEUP_ULP:      Serial.println("Wakeup caused by ULP program"); break;\n    default:                        Serial.printf("Wakeup was not caused by deep sleep: %d\\n", wakeup_reason); break;\n  }\n}\n\n\nvoid SDCard_Function(){\n    if(!SD.begin(21)){\n      Serial.println("Card Mount Failed");\n      return;\n  }\n  uint8_t cardType = SD.cardType();\n  if(cardType == CARD_NONE){\n      Serial.println("No SD card attached");\n      return;\n  }\n  Serial.print("SD Card Type: ");\n  if(cardType == CARD_MMC){\n      Serial.println("MMC");\n  } else if(cardType == CARD_SD){\n      Serial.println("SDSC");\n  } else if(cardType == CARD_SDHC){\n      Serial.println("SDHC");\n  } else {\n      Serial.println("UNKNOWN");\n  }\n\n  uint64_t cardSize = SD.cardSize() / (1024 * 1024);\n  Serial.printf("SD Card Size: %lluMB\\n", cardSize);\n  Serial.println("the sc card is connecting");\n}\n\nvoid Microphone_Function(){\n    // setup 42 PDM clock and 41 PDM data pins\n  I2S.setPinsPdmRx(42, 41);\n  // // start I2S at 16 kHz with 16-bits per sample\n  if (!I2S.begin(I2S_MODE_PDM_RX, 16000, I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_MONO)) {\n    Serial.println("Failed to initialize I2S!");\n    while (1); // do nothing\n  }\n  Serial.println("microphone is open");\n  // Stop reading after 5 seconds\n  delay(500);\n}\n\nvoid Camera_Function(){\n  Serial.setDebugOutput(true);\n  Serial.println();\n\n/*config\u8bbe\u7f6e*/\n  camera_config_t config;\n  config.ledc_channel = LEDC_CHANNEL_0;\n  config.ledc_timer = LEDC_TIMER_0;\n  config.pin_d0 = Y2_GPIO_NUM;\n  config.pin_d1 = Y3_GPIO_NUM;\n  config.pin_d2 = Y4_GPIO_NUM;\n  config.pin_d3 = Y5_GPIO_NUM;\n  config.pin_d4 = Y6_GPIO_NUM;\n  config.pin_d5 = Y7_GPIO_NUM;\n  config.pin_d6 = Y8_GPIO_NUM;\n  config.pin_d7 = Y9_GPIO_NUM;\n  config.pin_xclk = XCLK_GPIO_NUM;\n  config.pin_pclk = PCLK_GPIO_NUM;\n  config.pin_vsync = VSYNC_GPIO_NUM;\n  config.pin_href = HREF_GPIO_NUM;\n  config.pin_sccb_sda = SIOD_GPIO_NUM;\n  config.pin_sccb_scl = SIOC_GPIO_NUM;\n  config.pin_pwdn = PWDN_GPIO_NUM;\n  config.pin_reset = RESET_GPIO_NUM;\n  config.xclk_freq_hz = 20000000;\n  config.frame_size = FRAMESIZE_UXGA;\n  config.pixel_format = PIXFORMAT_JPEG;  // for streaming\n  //config.pixel_format = PIXFORMAT_RGB565; // for face detection/recognition\n  config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;\n  config.fb_location = CAMERA_FB_IN_PSRAM;\n  config.jpeg_quality = 12;\n  config.fb_count = 1;\n\n\n  // if PSRAM IC present, init with UXGA resolution and higher JPEG quality\n  //                      for larger pre-allocated frame buffer.\n  if (config.pixel_format == PIXFORMAT_JPEG) {\n    if (psramFound()) {\n      config.jpeg_quality = 10;\n      config.fb_count = 2;\n      config.grab_mode = CAMERA_GRAB_LATEST;\n    } else {\n      // Limit the frame size when PSRAM is not available\n      config.frame_size = FRAMESIZE_SVGA;\n      config.fb_location = CAMERA_FB_IN_DRAM;\n    }\n  } else {\n    // Best option for face detection/recognition\n    config.frame_size = FRAMESIZE_240X240;\n#if CONFIG_IDF_TARGET_ESP32S3\n    config.fb_count = 2;\n#endif\n  }\n\n#if defined(CAMERA_MODEL_ESP_EYE)\n  pinMode(13, INPUT_PULLUP);\n  pinMode(14, INPUT_PULLUP);\n#endif\n\n  // camera init\n  esp_err_t err = esp_camera_init(&config);\n  if (err != ESP_OK) {\n    Serial.printf("Camera init failed with error 0x%x", err);\n    return;\n  }\n\n  sensor_t *s = esp_camera_sensor_get();\n  // initial sensors are flipped vertically and colors are a bit saturated\n  if (s->id.PID == OV3660_PID) {\n    s->set_vflip(s, 1);        // flip it back\n    s->set_brightness(s, 1);   // up the brightness just a bit\n    s->set_saturation(s, -2);  // lower the saturation\n  }\n  // drop down frame size for higher initial frame rate\n  if (config.pixel_format == PIXFORMAT_JPEG) {\n    s->set_framesize(s, FRAMESIZE_QVGA);\n  }\n\n\n#if defined(CAMERA_MODEL_M5STACK_WIDE) || defined(CAMERA_MODEL_M5STACK_ESP32CAM)\n  s->set_vflip(s, 1);\n  s->set_hmirror(s, 1);\n#endif\n#if defined(CAMERA_MODEL_ESP32S3_EYE)\n  s->set_vflip(s, 1);\n#endif\n// Setup LED FLash if LED pin is defined in camera_pins.h\n#if defined(LED_GPIO_NUM)\n  setupLedFlash(LED_GPIO_NUM);\n#endif\n\n  Serial.println("the camera open");\n}\n\nvoid Deep_Sleep_Function(){\n  ++bootCount;\n  Serial.println("Boot number: " + String(bootCount));\n  //Print the wakeup reason for ESP32\n  print_wakeup_reason();\n  esp_sleep_enable_timer_wakeup(TIME_TO_SLEEP * uS_TO_S_FACTOR);//set wake up source\n  Serial.println("Setup ESP32 to sleep for every " + String(TIME_TO_SLEEP) + " Seconds");\n  Serial.println("Going to deep sleep now");\n  Serial.flush();\n  esp_deep_sleep_start();\n}\n\nvoid close_SDCard(){\n  SD.end();\n  Serial.println("the sd card already closed");\n}\nvoid close_Camera(){\n  esp_camera_deinit();\n  Serial.println("the camera already closed");\n}\nvoid close_Microphone(){\n  I2S.end();\n  Serial.println("the microphone already closed");\n}\n\n')),(0,o.yg)("admonition",{type:"tip"},(0,o.yg)("p",{parentName:"admonition"},"if use deep sleep mode in XIAO ESPS3 Sense ,you need to Put XIAO ESP32S3 Sense back into download mode , Press the boot button and then press reset")),(0,o.yg)("h2",{id:"modem-sleep"},"Modem-Sleep"),(0,o.yg)("h3",{id:"introduce-modem-sleep"},"Introduce Modem-Sleep"),(0,o.yg)("p",null,"Modem Sleep mode is another important low-power mode in ESP32, which is different from the Deep Sleep mode. Modem Sleep mode is primarily optimized for the wireless communication module of the ESP32."),(0,o.yg)("p",null,"In this mode, the WiFi/Bluetooth module of the ESP32 enters a sleep state, while the CPU cores remain active. This allows the ESP32 to maintain a certain level of wireless connectivity while significantly reducing the power consumption."),(0,o.yg)("h3",{id:"wake-up-methods-2"},"Wake-up Methods"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},"Timer Wake-up")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},"External Interrupt Wake-up")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},"Task Wake-up")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},"Network Activity Wake-up"))),(0,o.yg)("h3",{id:"use-modem-sleep-code"},"Use Modem Sleep Code"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},'#include <WiFi.h>\n#include <esp_wifi.h>\n#include <ESP_I2S.h>\n#include "FS.h"\n#include "SD.h"\n#include "SPI.h"\n#include "esp_camera.h"\n\n/*You cannot change the order here, otherwise an error will occur: no select camera mode*/\n#define CAMERA_MODEL_XIAO_ESP32S3 // Has PSRAM\n#include "camera_pins.h"\n/**************************/\nI2SClass I2S;\n\nconst char* ssid = "************";\nconst char* password = "***********";\n\n/*Declaration function*/\nvoid print_wakeup_reason();//print wake_up source \nvoid SDCard_enable();//SDCard begin \nvoid Microphone_enable();//Microphone begin \nvoid Camera_enable();//camera init \nvoid wifi_enable();//\nvoid Deep_Sleep_enable();//start deep_sleep\nvoid close_SDCard();\nvoid close_Camera();\nvoid close_Microphone();\nvoid startCameraServer();\nvoid setupLedFlash(int pin);\n\n\n\nvoid setup() {\n  Serial.begin(115200);\n  while(!Serial);\n}\n\nvoid loop() {\n  delay(500);\n  Serial.println("ready into deep sleep");\n  esp_deep_sleep_start();\n  Serial.flush();\n  delay(5000);\n}\n\n\nvoid Camera_enable(){\n  Serial.setDebugOutput(true);\n  Serial.println();\n\n/*config\u8bbe\u7f6e*/\n  camera_config_t config;\n  config.ledc_channel = LEDC_CHANNEL_0;\n  config.ledc_timer = LEDC_TIMER_0;\n  config.pin_d0 = Y2_GPIO_NUM;\n  config.pin_d1 = Y3_GPIO_NUM;\n  config.pin_d2 = Y4_GPIO_NUM;\n  config.pin_d3 = Y5_GPIO_NUM;\n  config.pin_d4 = Y6_GPIO_NUM;\n  config.pin_d5 = Y7_GPIO_NUM;\n  config.pin_d6 = Y8_GPIO_NUM;\n  config.pin_d7 = Y9_GPIO_NUM;\n  config.pin_xclk = XCLK_GPIO_NUM;\n  config.pin_pclk = PCLK_GPIO_NUM;\n  config.pin_vsync = VSYNC_GPIO_NUM;\n  config.pin_href = HREF_GPIO_NUM;\n  config.pin_sccb_sda = SIOD_GPIO_NUM;\n  config.pin_sccb_scl = SIOC_GPIO_NUM;\n  config.pin_pwdn = PWDN_GPIO_NUM;\n  config.pin_reset = RESET_GPIO_NUM;\n  config.xclk_freq_hz = 20000000;\n  config.frame_size = FRAMESIZE_UXGA;\n  config.pixel_format = PIXFORMAT_JPEG;  // for streaming\n  //config.pixel_format = PIXFORMAT_RGB565; // for face detection/recognition\n  config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;\n  config.fb_location = CAMERA_FB_IN_PSRAM;\n  config.jpeg_quality = 12;\n  config.fb_count = 1;\n\n\n  // if PSRAM IC present, init with UXGA resolution and higher JPEG quality\n  //                      for larger pre-allocated frame buffer.\n  if (config.pixel_format == PIXFORMAT_JPEG) {\n    if (psramFound()) {\n      config.jpeg_quality = 10;\n      config.fb_count = 2;\n      config.grab_mode = CAMERA_GRAB_LATEST;\n    } else {\n      // Limit the frame size when PSRAM is not available\n      config.frame_size = FRAMESIZE_SVGA;\n      config.fb_location = CAMERA_FB_IN_DRAM;\n    }\n  } else {\n    // Best option for face detection/recognition\n    config.frame_size = FRAMESIZE_240X240;\n#if CONFIG_IDF_TARGET_ESP32S3\n    config.fb_count = 2;\n#endif\n  }\n\n#if defined(CAMERA_MODEL_ESP_EYE)\n  pinMode(13, INPUT_PULLUP);\n  pinMode(14, INPUT_PULLUP);\n#endif\n\n  // camera init\n  esp_err_t err = esp_camera_init(&config);\n  if (err != ESP_OK) {\n    Serial.printf("Camera init failed with error 0x%x", err);\n    return;\n  }\n\n  sensor_t *s = esp_camera_sensor_get();\n  // initial sensors are flipped vertically and colors are a bit saturated\n  if (s->id.PID == OV3660_PID) {\n    s->set_vflip(s, 1);        // flip it back\n    s->set_brightness(s, 1);   // up the brightness just a bit\n    s->set_saturation(s, -2);  // lower the saturation\n  }\n  // drop down frame size for higher initial frame rate\n  if (config.pixel_format == PIXFORMAT_JPEG) {\n    s->set_framesize(s, FRAMESIZE_QVGA);\n  }\n\n\n#if defined(CAMERA_MODEL_M5STACK_WIDE) || defined(CAMERA_MODEL_M5STACK_ESP32CAM)\n  s->set_vflip(s, 1);\n  s->set_hmirror(s, 1);\n#endif\n#if defined(CAMERA_MODEL_ESP32S3_EYE)\n  s->set_vflip(s, 1);\n#endif\n// Setup LED FLash if LED pin is defined in camera_pins.h\n#if defined(LED_GPIO_NUM)\n  setupLedFlash(LED_GPIO_NUM);\n#endif\n\n  Serial.println("the camera open");\n}\n\nvoid SDCard_Function(){\n    if(!SD.begin(21)){\n      Serial.println("Card Mount Failed");\n      return;\n  }\n  uint8_t cardType = SD.cardType();\n  if(cardType == CARD_NONE){\n      Serial.println("No SD card attached");\n      return;\n  }\n  Serial.print("SD Card Type: ");\n  if(cardType == CARD_MMC){\n      Serial.println("MMC");\n  } else if(cardType == CARD_SD){\n      Serial.println("SDSC");\n  } else if(cardType == CARD_SDHC){\n      Serial.println("SDHC");\n  } else {\n      Serial.println("UNKNOWN");\n  }\n\n  uint64_t cardSize = SD.cardSize() / (1024 * 1024);\n  Serial.printf("SD Card Size: %lluMB\\n", cardSize);\n  Serial.println("the sc card is connecting");\n}\n\nvoid Microphone_Function(){\n    // setup 42 PDM clock and 41 PDM data pins\n  I2S.setPinsPdmRx(42, 41);\n  // // start I2S at 16 kHz with 16-bits per sample\n  if (!I2S.begin(I2S_MODE_PDM_RX, 16000, I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_MONO)) {\n    Serial.println("Failed to initialize I2S!");\n    while (1); // do nothing\n  }\n  Serial.println("microphone is open");\n  // Stop reading after 5 seconds\n  delay(500);\n}\n\nvoid wifi_enable(){\n  WiFi.mode(WIFI_STA);//set wifi client mode\n  esp_wifi_start();//enalbe wifi peripheral\n  Serial.println("Wifi open!");\n  WiFi.begin(ssid, password);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(".");\n  }\n  Serial.println("WiFi connected");\n  Serial.println("address ip is : ");\n  Serial.print(WiFi.localIP());\n}\n\nvoid Modem_Sleep_enalbe(){\n  //close wifi \n  WiFi.mode(WIFI_OFF);\n\n  //check whether or not\n  if (WiFi.getMode() == WIFI_OFF) {\n    Serial.println("WiFi is off");\n  } else {\n    Serial.println("WiFi is still on");\n  }\n}\n\nvoid close_SDCard(){\n  SD.end();\n  Serial.println("the sd card already closed");\n}\nvoid close_Camera(){\n  esp_camera_deinit();\n  Serial.println("the camera already closed");\n}\nvoid close_Microphone(){\n  I2S.end();\n  Serial.println("the microphone already closed");\n}\n\n')),(0,o.yg)("h2",{id:"to-conclude"},"To conclude"),(0,o.yg)("h3",{id:"why-use-deep-sleep-mode"},"Why use Deep Sleep mode"),(0,o.yg)("p",null,"maximize power savings without compromising functionality, in order to extend the battery life of the device.\nSuitable scenarios: Applications where battery life is crucial, such as remote sensor nodes, wearable devices, and other low-power IoT devices. Although the wakeup time is relatively slow, this trade-off is worthwhile."),(0,o.yg)("h3",{id:"why-use-light-sleep-mode"},"Why use Light Sleep mode"),(0,o.yg)("p",null,"reduce power consumption while still maintaining a certain level of responsiveness.\nSuitable scenarios: Applications that need to balance power consumption and performance, such as IoT devices with interactive interfaces and intermittently working sensor nodes. Compared to Deep Sleep, Light Sleep offers faster wakeup times."),(0,o.yg)("h3",{id:"why-use-modem-sleep-mode"},"Why use Modem Sleep mode"),(0,o.yg)("p",null,"optimize the power consumption of the wireless communication module, while still maintaining network connectivity.\nSuitable scenarios: Applications that need to maintain network connection but also require low power, such as intermittently working IoT devices. Modem Sleep can significantly reduce the power consumption of the wireless module while still providing fast wakeup response."),(0,o.yg)("h3",{id:"in-summary"},"In summary"),(0,o.yg)("p",null,"these three sleep modes provide developers with different power/performance trade-off options that can be flexibly chosen based on the specific requirements of the application. For devices with battery life requirements, Deep Sleep mode is a good choice; for applications that need to balance power consumption and responsiveness, Light Sleep is a better option; and for IoT devices that need to maintain network connectivity, Modem Sleep mode is the optimal choice."),(0,o.yg)("h2",{id:"tech-support--product-discussion"},"Tech Support & Product Discussion"),(0,o.yg)("p",null,"Thank you for choosing our products! We are here to provide you with different support to ensure that your experience with our products is as smooth as possible. We offer several communication channels to cater to different preferences and needs."),(0,o.yg)("div",{class:"button_tech_support_container"},(0,o.yg)("a",{href:"https://forum.seeedstudio.com/",class:"button_forum"}),(0,o.yg)("a",{href:"https://www.seeedstudio.com/contacts",class:"button_email"})),(0,o.yg)("div",{class:"button_tech_support_container"},(0,o.yg)("a",{href:"https://discord.gg/eWkprNDMU7",class:"button_discord"}),(0,o.yg)("a",{href:"https://github.com/Seeed-Studio/wiki-documents/discussions/69",class:"button_discussion"})))}_.isMDXComponent=!0}}]);